use litebox::fs::{FileSystem as _, Mode, OFlags};
use litebox::platform::RawConstPointer as _;
use litebox_common_linux::{EfdFlags, FcntlArg, FileDescriptorFlags, errno::Errno};
use litebox_platform_multiplex::{Platform, set_platform};

use super::file::{sys_dup, sys_eventfd2, sys_fcntl, sys_getdirent64, sys_open, sys_pipe2};
use crate::MutPtr;
use crate::syscalls::file::sys_close;

extern crate std;

// Ensure we only init the platform once
static INIT_FUNC: spin::Once = spin::Once::new();

const TEST_TAR_FILE: &[u8] = include_bytes!("../../../litebox/src/fs/test.tar");

pub(crate) fn init_platform(tun_device_name: Option<&str>) {
    INIT_FUNC.call_once(|| {
        #[cfg(target_os = "linux")]
        set_platform(Platform::new(tun_device_name));

        #[cfg(not(target_os = "linux"))]
        set_platform(Platform::new());

        let litebox = crate::litebox();
        let mut in_mem_fs = litebox::fs::in_mem::FileSystem::new(litebox);
        in_mem_fs.with_root_privileges(|fs| {
            fs.chmod("/", Mode::RWXU | Mode::RWXG | Mode::RWXO)
                .expect("Failed to set permissions on root");
        });
        let dev_stdio = litebox::fs::devices::stdio::FileSystem::new(litebox);
        let tar_ro_fs = litebox::fs::tar_ro::FileSystem::new(litebox, TEST_TAR_FILE.into());
        crate::set_fs(litebox::fs::layered::FileSystem::new(
            litebox,
            in_mem_fs,
            litebox::fs::layered::FileSystem::new(
                litebox,
                dev_stdio,
                tar_ro_fs,
                litebox::fs::layered::LayeringSemantics::LowerLayerReadOnly,
            ),
            litebox::fs::layered::LayeringSemantics::LowerLayerWritableFiles,
        ));
    });
}

pub(crate) fn compile(input: &str, output: &str, is_static: bool, nolibc: bool) {
    // Compile the hello.c file to an executable
    let mut args = alloc::vec!["-o", output, input];
    if is_static {
        args.push("-static");
    }
    if nolibc {
        args.push("-nostdlib");
    }
    args.push(match std::env::consts::ARCH {
        "x86_64" => "-m64",
        "x86" => "-m32",
        _ => unimplemented!(),
    });
    let output = std::process::Command::new("gcc")
        .args(args)
        .output()
        .expect("Failed to compile hello.c");
    assert!(
        output.status.success(),
        "failed to compile {input:} {:?}",
        std::str::from_utf8(output.stderr.as_slice()).unwrap()
    );
}

#[test]
fn test_fcntl() {
    init_platform(None);

    let check = |fd: i32, flags1: OFlags, flags2: OFlags| {
        assert_eq!(
            sys_fcntl(fd, FcntlArg::GETFD).unwrap(),
            FileDescriptorFlags::FD_CLOEXEC.bits()
        );

        assert_eq!(sys_fcntl(fd, FcntlArg::GETFL).unwrap(), flags1.bits());

        sys_fcntl(fd, FcntlArg::SETFD(FileDescriptorFlags::empty())).unwrap();
        assert_eq!(sys_fcntl(fd, FcntlArg::GETFD).unwrap(), 0);

        sys_fcntl(fd, FcntlArg::SETFL(OFlags::empty())).unwrap();
        assert_eq!(sys_fcntl(fd, FcntlArg::GETFL).unwrap(), flags2.bits());
    };

    // Test pipe
    let (read_fd, write_fd) =
        sys_pipe2(OFlags::CLOEXEC | OFlags::NONBLOCK).expect("Failed to create pipe");
    let read_fd = i32::try_from(read_fd).unwrap();
    check(read_fd, OFlags::RDONLY | OFlags::NONBLOCK, OFlags::RDONLY);
    let write_fd = i32::try_from(write_fd).unwrap();
    check(write_fd, OFlags::WRONLY | OFlags::NONBLOCK, OFlags::WRONLY);

    // Test eventfd
    let eventfd = sys_eventfd2(
        0,
        EfdFlags::CLOEXEC | EfdFlags::SEMAPHORE | EfdFlags::NONBLOCK,
    )
    .expect("Failed to create eventfd");
    let eventfd = i32::try_from(eventfd).unwrap();
    check(eventfd, OFlags::RDWR | OFlags::NONBLOCK, OFlags::RDWR);
}

#[test]
fn test_dup() {
    init_platform(None);

    let fd = sys_open("/dev/stdin", OFlags::RDONLY, Mode::empty()).unwrap();
    let fd = i32::try_from(fd).unwrap();
    // test dup
    let fd2 = sys_dup(fd, None, None).unwrap();
    let fd2 = i32::try_from(fd2).unwrap();
    assert_eq!(fd + 1, fd2);

    // test dup2
    let fd3 = sys_dup(fd2, Some(fd2 + 10), None).unwrap();
    let fd3 = i32::try_from(fd3).unwrap();
    assert_eq!(fd2 + 10, fd3);

    // test dup3
    assert_eq!(
        sys_dup(fd3, Some(fd3), Some(OFlags::CLOEXEC)),
        Err(Errno::EINVAL)
    );
    let fd4 = sys_dup(fd2, Some(fd2 + 10), Some(OFlags::CLOEXEC)).unwrap();
    let fd4 = i32::try_from(fd4).unwrap();
    assert_eq!(fd2 + 10, fd4);
}

// Note the test was generated by copilot with minor fixes.
#[allow(clippy::too_many_lines)]
#[test]
fn test_getdent64() {
    init_platform(None);

    // Create test files in root directory for testing
    let file1_fd = sys_open(
        "/test_file1.txt",
        OFlags::CREAT | OFlags::WRONLY,
        Mode::RUSR | Mode::WUSR,
    )
    .expect("Failed to create test_file1.txt");
    super::file::sys_close(file1_fd.try_into().unwrap()).expect("Failed to close test_file1.txt");

    let file2_fd = sys_open(
        "/test_file2.txt",
        OFlags::CREAT | OFlags::WRONLY,
        Mode::RUSR | Mode::WUSR,
    )
    .expect("Failed to create test_file2.txt");
    super::file::sys_close(file2_fd.try_into().unwrap()).expect("Failed to close test_file2.txt");

    // Open the root directory for testing
    let dir_fd =
        sys_open("/", OFlags::RDONLY, Mode::empty()).expect("Failed to open root directory");
    let dir_fd = dir_fd.try_into().unwrap();

    // Test 1: Basic functionality - read directory entries
    let mut buffer = alloc::vec![0u8; 4096];
    let bytes_read = sys_getdirent64(
        dir_fd,
        MutPtr::from_usize(buffer.as_mut_ptr() as usize),
        buffer.len(),
    )
    .expect("Failed to read directory entries");

    assert!(bytes_read > 0, "Should have read some directory entries");
    assert!(
        bytes_read <= buffer.len(),
        "Should not read more than buffer size"
    );

    // Parse the returned entries to verify they are correct
    let mut offset = 0;
    let mut found_entries = alloc::vec::Vec::new();

    while offset < bytes_read {
        assert!(
            unsafe { buffer.as_ptr().add(offset) }.addr()
                & (core::mem::align_of::<litebox_common_linux::LinuxDirent64>() - 1)
                == 0,
            "Pointer at offset {} is not aligned for LinuxDirent64 (requires {}-byte alignment)",
            offset,
            core::mem::align_of::<litebox_common_linux::LinuxDirent64>()
        );
        let dirent = unsafe {
            core::ptr::read_unaligned(
                buffer
                    .as_ptr()
                    .add(offset)
                    .cast::<litebox_common_linux::LinuxDirent64>(),
            )
        };

        // Validate the entry length
        assert!(dirent.len > 0, "Directory entry length must be positive");
        assert!(
            offset + dirent.len as usize <= bytes_read,
            "Entry should not exceed buffer"
        );

        let name_ptr = unsafe {
            buffer
                .as_ptr()
                .add(offset + core::mem::offset_of!(litebox_common_linux::LinuxDirent64, __name))
        };
        let name_len = dirent.len as usize
            - core::mem::offset_of!(litebox_common_linux::LinuxDirent64, __name);
        let name_bytes = unsafe { core::slice::from_raw_parts(name_ptr, name_len) };

        // Find the null terminator
        let null_pos = name_bytes
            .iter()
            .position(|&b| b == 0)
            .unwrap_or(name_bytes.len());
        let name =
            core::str::from_utf8(&name_bytes[..null_pos]).expect("Invalid UTF-8 in filename");

        found_entries.push((alloc::string::String::from(name), dirent.typ, dirent.ino));
        offset += dirent.len as usize;
    }

    assert!(
        !found_entries.is_empty(),
        "Should find at least some directory entries"
    );

    // Check that our test files appear in the directory listing
    let mut entry_names: alloc::vec::Vec<alloc::string::String> = found_entries
        .iter()
        .map(|(name, _, _)| name.clone())
        .collect();
    entry_names.sort();
    assert_eq!(
        entry_names,
        alloc::vec![".", "..", "bar", "foo", "test_file1.txt", "test_file2.txt"]
    );

    // Verify that our test files have the correct type (regular file)
    for (name, typ, _) in &found_entries {
        if name == "test_file1.txt" || name == "test_file2.txt" {
            assert_eq!(
                *typ,
                litebox_common_linux::DirentType::Regular as u8,
                "Test files should have Regular type"
            );
        }
    }

    assert_eq!(
        sys_getdirent64(
            dir_fd,
            MutPtr::from_usize(buffer.as_mut_ptr() as usize),
            buffer.len()
        )
        .expect("Failed to read directory entries"),
        0,
        "should have read all entries in the previous call"
    );
    sys_close(dir_fd).expect("Failed to close directory");

    // Test 2: Small buffer (should handle partial reads gracefully)
    let dir_fd =
        sys_open("/", OFlags::RDONLY, Mode::empty()).expect("Failed to open root directory");
    let dir_fd = dir_fd.try_into().unwrap();
    let mut small_buffer = [0u8; 64];
    let bytes = sys_getdirent64(
        dir_fd,
        MutPtr::from_usize(small_buffer.as_mut_ptr() as usize),
        small_buffer.len(),
    )
    .expect("Failed to read directory entries");

    // Should either succeed with partial data or return 0 if no entry fits
    assert!(bytes <= small_buffer.len(), "Should not exceed buffer size");
    // If bytes > 0, verify the structure is valid
    if bytes > 0 {
        let dirent = unsafe {
            core::ptr::read_unaligned(
                small_buffer
                    .as_ptr()
                    .cast::<litebox_common_linux::LinuxDirent64>(),
            )
        };
        assert!(
            dirent.len as usize <= bytes,
            "First entry length should fit in returned bytes"
        );
        assert!(dirent.len > 0, "Entry length should be positive");
    }

    // Test 3: Invalid file descriptor
    let result = sys_getdirent64(
        -1,
        MutPtr::from_usize(buffer.as_mut_ptr() as usize),
        buffer.len(),
    );
    assert_eq!(
        result,
        Err(Errno::EBADF),
        "Should return EBADF for invalid fd"
    );

    // Test 4: File descriptor pointing to a regular file (not a directory)
    let file1_fd = sys_open("/test_file1.txt", OFlags::RDONLY, Mode::empty())
        .expect("Failed to open test_file1.txt");
    let file1_fd = file1_fd.try_into().unwrap();

    let result = sys_getdirent64(
        file1_fd,
        MutPtr::from_usize(buffer.as_mut_ptr() as usize),
        buffer.len(),
    );
    assert_eq!(
        result,
        Err(Errno::ENOTDIR),
        "Should return ENOTDIR for non-directory fd"
    );
    super::file::sys_close(file1_fd).expect("Failed to close file");

    // Test 5: Zero-length buffer
    let result = sys_getdirent64(dir_fd, MutPtr::from_usize(buffer.as_mut_ptr() as usize), 0);
    assert_eq!(result, Ok(0), "Should return 0 for zero-length buffer");

    sys_close(dir_fd).expect("Failed to close directory");

    // Test 6: Multiple reads (test directory offset tracking)
    // Reopen directory to reset position
    let dir_fd2 =
        sys_open("/", OFlags::RDONLY, Mode::empty()).expect("Failed to reopen root directory");
    let dir_fd2 = dir_fd2.try_into().unwrap();

    // Read entries in smaller chunks to test offset tracking
    let mut all_entries = alloc::vec::Vec::new();

    loop {
        let mut chunk_buffer = [0u8; 64];
        let bytes_read = sys_getdirent64(
            dir_fd2,
            MutPtr::from_usize(chunk_buffer.as_mut_ptr() as usize),
            chunk_buffer.len(),
        )
        .expect("Failed to read directory chunk");

        if bytes_read == 0 {
            break; // End of directory
        }

        // Parse entries from this chunk
        let mut offset = 0;
        while offset < bytes_read {
            let dirent = unsafe {
                core::ptr::read_unaligned(
                    chunk_buffer
                        .as_ptr()
                        .add(offset)
                        .cast::<litebox_common_linux::LinuxDirent64>(),
                )
            };

            assert!(dirent.len > 0, "Entry length must be positive");
            assert!(
                offset + dirent.len as usize <= bytes_read,
                "Entry should fit in chunk"
            );

            let name_ptr = unsafe {
                chunk_buffer.as_ptr().add(
                    offset + core::mem::offset_of!(litebox_common_linux::LinuxDirent64, __name),
                )
            };
            let name_len = dirent.len as usize
                - core::mem::offset_of!(litebox_common_linux::LinuxDirent64, __name);
            let name_bytes = unsafe { core::slice::from_raw_parts(name_ptr, name_len) };

            let null_pos = name_bytes
                .iter()
                .position(|&b| b == 0)
                .unwrap_or(name_bytes.len());
            let name =
                core::str::from_utf8(&name_bytes[..null_pos]).expect("Invalid UTF-8 in filename");

            all_entries.push(alloc::string::String::from(name));
            offset += dirent.len as usize;
        }
    }

    // Verify we still got our expected entries through chunked reading
    all_entries.sort();
    assert_eq!(
        all_entries,
        alloc::vec![".", "..", "bar", "foo", "test_file1.txt", "test_file2.txt"]
    );
}
